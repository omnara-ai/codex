use std::sync::{Arc, Mutex};
use std::path::PathBuf;
use std::io::Write as _;

use reqwest::Url;
use serde::{Deserialize, Serialize};
use tokio::task::JoinHandle;
use tokio_util::sync::CancellationToken;
use tracing::{debug, error, info, trace, warn};
use crate::git_diff_tracker::GitDiffTracker;

/// Omnara API client with minimal surface for Codex integration.
///
/// Responsibilities:
/// - Send agent messages (track last agent message id)
/// - Request user input on the last agent message
/// - Poll for pending user messages (single concurrent poller)
#[derive(Clone)]
pub struct OmnaraClient {
    http: reqwest::Client,
    base_url: String,
    api_key: String,
    session_id: uuid::Uuid,
    last_agent_message_id: Arc<Mutex<Option<String>>>,
    poller: Arc<Mutex<PollerState>>, // single active poller
    wrapper_log: PathBuf,
    git: Option<Arc<Mutex<GitDiffTracker>>>,
}

#[derive(Default)]
struct PollerState {
    cancel: Option<CancellationToken>,
    handle: Option<JoinHandle<()>>,
}

#[derive(Debug, Serialize)]
struct AgentMessageRequest<'a> {
    agent_instance_id: &'a str,
    content: &'a str,
    #[serde(default)]
    requires_user_input: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    agent_type: Option<&'a str>,
    #[serde(skip_serializing_if = "Option::is_none")]
    git_diff: Option<&'a str>,
    #[serde(skip_serializing_if = "Option::is_none")]
    send_push: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    send_email: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    send_sms: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct AgentMessageResponse {
    message_id: String,
}

#[derive(Debug, Deserialize)]
struct PendingMessagesResponse {
    messages: Vec<PendingMessage>,
    status: String, // "ok" | "stale"
}

#[derive(Debug, Deserialize, Clone)]
struct PendingMessage {
    pub content: String,
    #[allow(dead_code)]
    pub sender_type: Option<String>,
    #[allow(dead_code)]
    pub created_at: Option<String>,
    #[allow(dead_code)]
    pub requires_user_input: Option<bool>,
}

impl OmnaraClient {
    /// Construct a client from env vars. Returns None when not configured.
    /// Env vars:
    /// - OMNARA_API_KEY (required to enable)
    /// - OMNARA_API_URL (optional; defaults to hosted URL)
    /// - OMNARA_SESSION_ID (optional; autogenerated if missing)
    pub fn from_env() -> Option<Self> {
        let api_key = match std::env::var("OMNARA_API_KEY") {
            Ok(v) => v,
            Err(_) => {
                debug!("Omnara disabled: OMNARA_API_KEY not set");
                return None;
            }
        };
        let base_url = std::env::var("OMNARA_API_URL")
            .ok()
            .unwrap_or_else(|| "https://agent-dashboard-mcp.onrender.com".to_string());
        let session_id = std::env::var("OMNARA_SESSION_ID")
            .ok()
            .and_then(|s| uuid::Uuid::parse_str(&s).ok())
            .unwrap_or_else(uuid::Uuid::new_v4);

        info!(base_url = %base_url, session_id = %session_id, "Initializing OmnaraClient from env");
        Some(Self::new(api_key, base_url, session_id))
    }

    /// End the Omnara session (POST /api/v1/sessions/end).
    pub async fn end_session(&self) -> crate::error::Result<()> {
        #[derive(Serialize)]
        struct EndReq<'a> {
            agent_instance_id: &'a str,
        }
        info!(session_id = %self.session_id, "Omnara end_session: begin");
        let req = EndReq {
            agent_instance_id: &self.session_id.to_string(),
        };
        let url = self.url("/api/v1/sessions/end");
        info!(url = %url, "Omnara end_session: POST");
        let resp = self.auth(self.http.post(url)).json(&req).send().await?;
        let status = resp.status();
        debug!(status = %status, "Omnara end_session: response status");
        if !status.is_success() {
            let text = resp.text().await.unwrap_or_default();
            error!(status = %status, body = %text, "Omnara end_session: error");
            return Err(crate::error::CodexErr::UnexpectedStatus(status, text));
        }
        info!("Omnara end_session: success");
        Ok(())
    }
    /// Send a local user message to Omnara for this session.
    pub async fn send_user_message(&self, content: &str, mark_as_read: bool) -> crate::error::Result<String> {
        debug!(content_len = content.len(), mark_as_read, "Omnara send_user_message: begin");
        #[derive(Serialize)]
        struct UserMessageReq<'a> {
            agent_instance_id: &'a str,
            content: &'a str,
            mark_as_read: bool,
        }
        #[derive(Deserialize)]
        struct UserMessageResp { message_id: String }

        let req = UserMessageReq {
            agent_instance_id: &self.session_id.to_string(),
            content,
            mark_as_read,
        };
        let url = self.url("/api/v1/messages/user");
        info!(url = %url, "Omnara send_user_message: POST");
        let resp = self
            .auth(self.http.post(url))
            .json(&req)
            .send()
            .await?;
        let status = resp.status();
        debug!(status = %status, "Omnara send_user_message: response status");
        if !status.is_success() {
            let text = resp.text().await.unwrap_or_default();
            error!(status = %status, body = %text, "Omnara send_user_message: error");
            return Err(crate::error::CodexErr::UnexpectedStatus(status, text));
        }
        let parsed: UserMessageResp = resp.json().await?;
        info!(message_id = %parsed.message_id, "Omnara send_user_message: success");
        Ok(parsed.message_id)
    }

    pub fn new(api_key: String, base_url: String, session_id: uuid::Uuid) -> Self {
        info!(base_url = %base_url, session_id = %session_id, "Creating OmnaraClient");
        let wrapper_log = Self::init_wrapper_log_path(session_id);
        let this = Self {
            http: reqwest::Client::new(),
            base_url: base_url.trim_end_matches('/').to_string(),
            api_key,
            session_id,
            last_agent_message_id: Arc::new(Mutex::new(None)),
            poller: Arc::new(Mutex::new(PollerState::default())),
            wrapper_log,
            git: Some(Arc::new(Mutex::new(GitDiffTracker::new(true, None)))),
        };
        this.append_log(&format!(
            "=== OMNARA CLIENT INITIALIZED ===\nTime: {}\nSession ID: {}\nAPI URL: {}\n\n",
            chrono::Utc::now().to_rfc3339(),
            this.session_id,
            this.base_url
        ));
        this
    }

    pub fn session_id(&self) -> uuid::Uuid {
        self.session_id
    }

    #[allow(clippy::expect_used)]
    fn url(&self, path: &str) -> reqwest::Url {
        let base = Url::parse(&self.base_url).expect("valid OMNARA_API_URL");
        base.join(path).expect("valid API path")
    }

    fn auth(&self, req: reqwest::RequestBuilder) -> reqwest::RequestBuilder {
        req.bearer_auth(&self.api_key)
    }

    /// Set the last-read message id used when polling for pending messages.
    pub fn set_last_read_message_id(&self, id: String) {
        if let Ok(mut guard) = self.last_agent_message_id.lock() {
            *guard = Some(id);
        }
    }

    /// Send an agent message. When `requires_user_input` is false, the returned
    /// message id is recorded as the last agent message id.
    pub async fn send_agent_message(
        &self,
        content: &str,
        requires_user_input: bool,
    ) -> crate::error::Result<String> {
        debug!(content_len = content.len(), requires_user_input, session_id = %self.session_id, "Omnara send_agent_message: begin");
        // Compute git diff if changed; include when present.
        let git_diff = if let Some(g) = &self.git {
            if let Ok(mut guard) = g.lock() {
                guard.get_diff_if_changed()
            } else {
                None
            }
        } else {
            None
        };

        let body = AgentMessageRequest {
            agent_instance_id: &self.session_id.to_string(),
            content,
            requires_user_input,
            agent_type: Some("codex"),
            git_diff: git_diff.as_deref(),
            send_push: None,
            send_email: None,
            send_sms: None,
        };

        let url = self.url("/api/v1/messages/agent");
        info!(url = %url, "Omnara send_agent_message: POST");
        self.append_log(&format!(
            "--- SENDING AGENT MESSAGE ---\nTime: {}\nURL: {}\nRequires Input: {}\nContent: {}\n\n",
            chrono::Utc::now().to_rfc3339(),
            url,
            requires_user_input,
            content
        ));
        let resp = self
            .auth(self.http.post(url))
            .json(&body)
            .send()
            .await?;

        let status = resp.status();
        debug!(status = %status, "Omnara send_agent_message: response status");
        if !status.is_success() {
            let text = resp.text().await.unwrap_or_default();
            error!(status = %status, body = %text, "Omnara send_agent_message: error");
        self.append_log(&format!("Response Status: {status}\nBody: {text}\n\n"));
            return Err(crate::error::CodexErr::UnexpectedStatus(status, text));
        }

        let parsed: AgentMessageResponse = resp.json().await?;
        self.append_log(&format!(
            "Response Status: {}\nMessage ID: {}\n\u{2713} Message sent successfully\n\n",
            status,
            parsed.message_id
        ));
        info!(message_id = %parsed.message_id, requires_user_input, "Omnara send_agent_message: success");

        if !requires_user_input
            && let Ok(mut guard) = self.last_agent_message_id.lock()
        {
            *guard = Some(parsed.message_id.clone());
            debug!(last_agent_message_id = guard.as_deref().unwrap_or("<none>"), "Updated last_agent_message_id");
        }

        Ok(parsed.message_id)
    }

    /// Request user input for the last recorded agent message id.
    pub async fn request_user_input_for_last_message(&self) -> crate::error::Result<()> {
        let last_id = self
            .last_agent_message_id
            .lock()
            .ok()
            .and_then(|g| g.clone());

        let Some(message_id) = last_id else {
            // Nothing to request; silently ignore.
            debug!("request_user_input: no last_agent_message_id set (noop)");
            return Ok(());
        };

        info!(message_id = %message_id, "request_user_input: begin");
        let url = self.url(&format!("/api/v1/messages/{message_id}/request-input"));
        info!(url = %url, "request_user_input: PATCH");
        self.append_log(&format!(
            "--- REQUEST USER INPUT ---\nTime: {}\nURL: {}\nMessage: last_agent_message\n\n",
            chrono::Utc::now().to_rfc3339(),
            url
        ));
        let resp = self.auth(self.http.patch(url)).send().await?;
        let status = resp.status();
        debug!(status = %status, "request_user_input: response status");
        if !status.is_success() {
            let text = resp.text().await.unwrap_or_default();
            error!(status = %status, body = %text, "request_user_input: error");
            self.append_log(&format!("Response Status: {status}\nBody: {text}\n\n"));
            return Err(crate::error::CodexErr::UnexpectedStatus(status, text));
        }
        info!("request_user_input: success");
        self.append_log("\u{2713} Request user input updated successfully\n\n");
        Ok(())
    }

    /// Start polling for pending messages. Cancels any existing poller.
    ///
    /// - `on_message` is invoked for each message received in a poll cycle.
    /// - After delivering messages from a single response, the poller exits.
    pub fn start_polling<F>(&self, mut on_message: F)
    where
        F: FnMut(String) + Send + 'static,
    {
        // Cancel any existing poller.
        self.cancel_polling();
        info!("Omnara polling: start");
        self.append_log(&format!(
            "--- STARTING POLLING FOR USER RESPONSE ---\nTime: {}\nURL: {}\nTimeout: 24 hours (5-second intervals)\n\n",
            chrono::Utc::now().to_rfc3339(),
            {
                let last_read = self
                    .last_agent_message_id
                    .lock()
                    .ok()
                    .and_then(|o| o.clone())
                    .unwrap_or_else(|| "<none>".to_string());
                format!(
                    "{}/api/v1/messages/pending?agent_instance_id={}&last_read_message_id={}",
                    self.base_url, self.session_id, last_read
                )
            }
        ));

        let cancel = CancellationToken::new();
        let cancel_child = cancel.child_token();
        let (base_url, api_key, session_id) = (
            self.base_url.clone(),
            self.api_key.clone(),
            self.session_id,
        );
        let wrapper_log_path = self.wrapper_log.clone();

        // Use the last known agent message id as last_read_message_id.
        let last_read = self
            .last_agent_message_id
            .lock()
            .ok()
            .and_then(|g| g.clone());

        let http = self.http.clone();

        let handle = tokio::spawn(async move {
            let poll_interval_secs = 5u64;
            let timeout_secs = 24 * 60 * 60u64; // 24h
            let start = std::time::Instant::now();
            let last_id = last_read;

            loop {
                if cancel_child.is_cancelled() {
                    info!("Omnara polling: cancelled");
                    break;
                }

                if start.elapsed().as_secs() > timeout_secs {
                    info!("Omnara polling: timeout reached (24h) ending");
                    break;
                }

                // Build request
                #[allow(clippy::expect_used)]
                let url = Url::parse(&base_url)
                    .and_then(|u| u.join("/api/v1/messages/pending"))
                    .expect("valid pending URL");
                let mut req = http.get(url.clone()).bearer_auth(&api_key).query(&[
                    ("agent_instance_id", session_id.to_string()),
                ]);
                if let Some(ref id) = last_id {
                    req = req.query(&[("last_read_message_id", id.clone())]);
                }
                trace!(url = %url, last_read = ?last_id, "Omnara polling: GET pending");
                match req.send().await {
                    Ok(resp) if resp.status().is_success() => {
                        let status = resp.status();
                        debug!(status = %status, "Omnara polling: response status");
                        let Ok(pending) = resp.json::<PendingMessagesResponse>().await else {
                            // Malformed JSON, wait and retry
                            warn!("Omnara polling: invalid JSON response; retrying");
                            tokio::time::sleep(std::time::Duration::from_secs(poll_interval_secs))
                                .await;
                            continue;
                        };

                        if pending.status == "stale" {
                            // Another reader consumed messages; stop.
                            info!("Omnara polling: stale status; exiting");
                            break;
                        }
                        // Write a per-poll summary for visibility.
                        let _ = (|| {
                            let mut f = std::fs::OpenOptions::new()
                                .create(true)
                                .append(true)
                                .open(&wrapper_log_path)?;
                            writeln!(
                                f,
                                "Poll: Status: {} OK, Messages: {}",
                                status.as_u16(),
                                pending.messages.len()
                            )?;
                            f.flush()?;
                            Ok::<(), std::io::Error>(())
                        })();

                        if !pending.messages.is_empty() {
                            // Deliver messages and exit after this cycle.
                            info!(count = pending.messages.len(), "Omnara polling: messages received");
                            for m in pending.messages {
                                on_message(m.content);
                            }
                            info!("Omnara polling: delivered messages; exiting");
                            break;
                        }
                    }
                    Ok(resp) => {
                        let status = resp.status();
                        warn!(status = %status, "Omnara polling: non-success status; retrying");
                    }
                    Err(_) => {
                        warn!("Omnara polling: network error; retrying");
                    }
                }

                tokio::select! {
                    _ = cancel_child.cancelled() => break,
                    _ = tokio::time::sleep(std::time::Duration::from_secs(poll_interval_secs)) => {}
                }
            }
        });

        if let Ok(mut state) = self.poller.lock() {
            state.cancel = Some(cancel);
            state.handle = Some(handle);
        }
    }

    /// Cancel any active polling task.
    pub fn cancel_polling(&self) {
        if let Ok(mut state) = self.poller.lock() {
            if let Some(token) = state.cancel.take() {
                info!("Omnara polling: cancel requested");
                token.cancel();
            }
            if let Some(handle) = state.handle.take() {
                // Detach; task will observe cancellation token and exit.
                std::mem::drop(handle);
            }
        }
    }

    fn init_wrapper_log_path(session_id: uuid::Uuid) -> PathBuf {
        // ~/.omnara/codex_wrapper/<session_id>.log
        let mut dir = dirs::home_dir().unwrap_or_else(|| PathBuf::from("."));
        dir.push(".omnara");
        dir.push("codex_wrapper");
        let _ = std::fs::create_dir_all(&dir);
        let mut path = dir;
        path.push(format!("{session_id}.log"));
        path
    }

    /// Append a line to the per-session wrapper log file.
    pub fn append_log(&self, text: &str) {
        if let Ok(mut f) = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.wrapper_log)
        {
            let _ = f.write_all(text.as_bytes());
            let _ = f.flush();
        }
    }
}
